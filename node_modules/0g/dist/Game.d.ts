import { QueryManager } from './QueryManager.js';
import { ComponentManager } from './ComponentManager.js';
import { IdManager } from './IdManager.js';
import { ArchetypeManager } from './ArchetypeManager.js';
import { Operation } from './operations.js';
import { Entity } from './Entity.js';
import { Resources } from './Resources.js';
import { ObjectPool } from './internal/objectPool.js';
import { Assets } from './Assets.js';
import { QueryComponentFilter } from './Query.js';
import { EntityImpostorFor } from './QueryIterator.js';
import type { AssetLoaders, BaseShape, Globals } from './index.js';
import { EventSubscriber } from '@a-type/utils';
import { ComponentHandle } from './Component2.js';
export type GameConstants = {
    maxComponentId: number;
    maxEntities: number;
};
export type GameEvents = {
    preStep(): any;
    step(): any;
    postStep(): any;
    stepComplete(): any;
    preApplyOperations(): any;
    destroyEntities(): any;
};
export declare class Game extends EventSubscriber<GameEvents> {
    private _queryManager;
    private _idManager;
    private _archetypeManager;
    private _operationQueue;
    private _componentManager;
    private _globals;
    private _runnableCleanups;
    private _entityPool;
    private _removedList;
    private _assets;
    private _phases;
    private _delta;
    private _time;
    private _constants;
    constructor({ components, systems, assetLoaders, }: {
        components: ComponentHandle[];
        systems?: ((game: Game) => () => void)[];
        assetLoaders?: AssetLoaders;
    });
    get idManager(): IdManager;
    get componentManager(): ComponentManager;
    get archetypeManager(): ArchetypeManager;
    get delta(): number;
    get time(): number;
    get queryManager(): QueryManager;
    get constants(): GameConstants;
    get globals(): Resources<Globals>;
    get assets(): Assets<AssetLoaders>;
    get entityPool(): ObjectPool<Entity<ComponentHandle, any>>;
    /**
     * Allocates a new entity id and enqueues an operation to create the entity at the next opportunity.
     */
    create: () => number;
    /**
     * Enqueues an entity to be destroyed at the next opportunity
     */
    destroy: (id: number) => void;
    /**
     * Add a component to an entity.
     */
    add: <ComponentShape extends BaseShape>(entityId: number, handle: ComponentHandle<ComponentShape>, initial?: Partial<ComponentShape>) => void;
    /**
     * Remove a component by type from an entity
     */
    remove: <T extends ComponentHandle>(entityId: number, Type: T) => void;
    /**
     * Get a single entity by its known ID
     */
    get: (entityId: number) => Entity<any> | null;
    /**
     * Run some logic for each entity that meets an ad-hoc query.
     */
    query: <Filter extends QueryComponentFilter>(filter: Filter, run: (entity: EntityImpostorFor<Filter>, game: this) => void) => void;
    find: <Filter extends QueryComponentFilter>(filter: Filter) => EntityImpostorFor<Filter>[];
    findFirst: <Filter extends QueryComponentFilter>(filter: Filter) => EntityImpostorFor<Filter> | null;
    /**
     * Manually step the game simulation forward. Provide a
     * delta (in ms) of time elapsed since last frame.
     */
    step: (delta: number) => void;
    enqueueOperation: (operation: Operation) => void;
    private destroyEntity;
    private flushOperations;
    private applyOperation;
}
