import { QueryManager } from './QueryManager.js';
import { ComponentManager } from './ComponentManager.js';
import { IdManager } from './IdManager.js';
import { ArchetypeManager } from './ArchetypeManager.js';
import { Entity } from './Entity.js';
import { Resources } from './Resources.js';
import { ObjectPool } from './internal/objectPool.js';
import { RemovedList } from './RemovedList.js';
import { Assets } from './Assets.js';
import { EventSubscriber } from '@a-type/utils';
export class Game extends EventSubscriber {
    constructor({ components, systems = [], assetLoaders = {}, }) {
        super();
        this._idManager = new IdManager();
        this._operationQueue = [];
        this._globals = new Resources();
        this._entityPool = new ObjectPool(() => new Entity(), (e) => e.reset());
        this._removedList = new RemovedList();
        // TODO: configurable?
        this._phases = ['preStep', 'step', 'postStep'];
        this._delta = 0;
        this._time = 0;
        this._constants = {
            maxComponentId: 256,
            maxEntities: 2 ** 16,
        };
        /**
         * Allocates a new entity id and enqueues an operation to create the entity at the next opportunity.
         */
        this.create = () => {
            const id = this.idManager.get();
            this._operationQueue.push({
                op: 'createEntity',
                entityId: id,
            });
            return id;
        };
        /**
         * Enqueues an entity to be destroyed at the next opportunity
         */
        this.destroy = (id) => {
            this._operationQueue.push({
                op: 'removeEntity',
                entityId: id,
            });
        };
        /**
         * Add a component to an entity.
         */
        this.add = (entityId, handle, initial) => {
            this._operationQueue.push({
                op: 'addComponent',
                entityId,
                componentType: handle.id,
                initialValues: initial,
            });
        };
        /**
         * Remove a component by type from an entity
         */
        this.remove = (entityId, Type) => {
            this._operationQueue.push({
                op: 'removeComponent',
                entityId,
                componentType: Type.id,
            });
        };
        /**
         * Get a single entity by its known ID
         */
        this.get = (entityId) => {
            var _a;
            return ((_a = this.archetypeManager.getEntity(entityId)) !== null && _a !== void 0 ? _a : this._removedList.get(entityId));
        };
        /**
         * Run some logic for each entity that meets an ad-hoc query.
         */
        this.query = (filter, run) => {
            const query = this._queryManager.create(filter);
            let ent;
            for (ent of query) {
                run(ent, this);
            }
        };
        this.find = (filter) => {
            const query = this._queryManager.create(filter);
            return Array.from(query);
        };
        this.findFirst = (filter) => {
            var _a;
            const query = this._queryManager.create(filter);
            return (_a = query.iterator.next().value) !== null && _a !== void 0 ? _a : null;
        };
        /**
         * Manually step the game simulation forward. Provide a
         * delta (in ms) of time elapsed since last frame.
         */
        this.step = (delta) => {
            this._delta = delta;
            this._phases.forEach((phase) => {
                this.emit(phase);
            });
            this.emit('destroyEntities');
            this._removedList.flush(this.destroyEntity);
            this.emit('preApplyOperations');
            this.flushOperations();
            this.emit('stepComplete');
        };
        this.enqueueOperation = (operation) => {
            this._operationQueue.push(operation);
        };
        this.destroyEntity = (entity) => {
            entity.components.forEach((instance) => {
                if (instance)
                    this.componentManager.release(instance);
            });
            this.entityPool.release(entity);
        };
        this.flushOperations = () => {
            while (this._operationQueue.length) {
                this.applyOperation(this._operationQueue.shift());
            }
        };
        this.applyOperation = (operation) => {
            let instance;
            let entity;
            switch (operation.op) {
                case 'addComponent':
                    if (operation.entityId === 0)
                        break;
                    instance = this.componentManager.acquire(operation.componentType, operation.initialValues);
                    this.archetypeManager.addComponent(operation.entityId, instance);
                    break;
                case 'removeComponent':
                    if (operation.entityId === 0)
                        break;
                    instance = this.archetypeManager.removeComponent(operation.entityId, operation.componentType);
                    if (instance) {
                        this.componentManager.release(instance);
                    }
                    break;
                case 'createEntity':
                    this.archetypeManager.createEntity(operation.entityId);
                    break;
                case 'removeEntity':
                    if (operation.entityId === 0)
                        break;
                    entity = this.archetypeManager.destroyEntity(operation.entityId);
                    this._removedList.add(entity);
                    break;
                case 'markChanged':
                    this.componentManager.markChanged(operation.componentId);
                    break;
            }
        };
        this._componentManager = new ComponentManager(components, this);
        this._assets = new Assets(assetLoaders);
        this._queryManager = new QueryManager(this);
        this._archetypeManager = new ArchetypeManager(this);
        this._runnableCleanups = systems.map((sys) => sys(this));
    }
    get idManager() {
        return this._idManager;
    }
    get componentManager() {
        return this._componentManager;
    }
    get archetypeManager() {
        return this._archetypeManager;
    }
    get delta() {
        return this._delta;
    }
    get time() {
        return this._time;
    }
    get queryManager() {
        return this._queryManager;
    }
    get constants() {
        return this._constants;
    }
    get globals() {
        return this._globals;
    }
    get assets() {
        return this._assets;
    }
    get entityPool() {
        return this._entityPool;
    }
}
//# sourceMappingURL=Game.js.map